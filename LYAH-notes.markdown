# Introduction 
 
* imperative languages
  * computes by a sequence of tasks, changing state
  * control flow structures for looping
* functional progamming
  * compute by telling what stuff is
  * functions have no side effects - functions can only calculate inputs and return a result
* **referencial transparency** - if a function is called twice with the same parameters, it will always returns the same result
* **lazy** - wont execute functions unless forced to show a result
* **statically typed** - type is known at compile time
  * lots of errors caught at compile time
* **type inference** - dont have to explicitly label every piece of code with a type

interactive mode
$ ghci 

load functions
:l myfunctions

reload current script
:r 

# Starting out
http://learnyouahaskell.com/starting-out

34 + 234
